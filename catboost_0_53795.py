# -*- coding: utf-8 -*-
"""Recruit Restaurant Visitor Forecasting_CATBoost_0.53795.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZYaofZXKbR3PUR6tC8lrBiiEenoxNmSY
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import KFold, train_test_split
import random
from sklearn.metrics import mean_squared_error as mse

import warnings
warnings.filterwarnings('ignore')
import gc

def RMSLE(y_pred, y_test):
    return np.sqrt(mse(y_test,y_pred))

train=pd.read_csv('Recruit_Restaurant_train.csv')
test=pd.read_csv('Recruit_Restaurant_test.csv')

train.drop(['air_store_id','visit_date','latitude','longitude'], axis=1, inplace=True)
test.drop(['air_store_id','visit_date','latitude','longitude'], axis=1, inplace=True)

X=train.drop('visitors', axis=1)
y=train['visitors']
X_test=test

X_tr, X_te, y_tr, y_te=train_test_split(X, y, test_size=0.2,random_state=42)

cat_cols=[col for col in X.columns if X[col].dtype in ['object', 'category'] ]
cat_cols

def seed_everything(seed=0):
    random.seed(seed)
    np.random.seed(seed)

! pip install catboost

from catboost import CatBoostRegressor

SEED=2022
seed_everything(SEED)

cat_params = {
    'n_estimators':5000,
    'learning_rate': 0.07,
    'eval_metric':'RMSE',
    'loss_function':'RMSE',
    'random_seed':SEED,
    'metric_period':500,#The frequency of iterations to calculate the values of objectives and metrics.
    'od_wait':500,#The number of iterations to continue the training after the iteration with the optimal metric value.
    'task_type':'GPU',
    'depth': 16
}

def find_Best_Iteration(X_tr, y_tr, X_te, y_te, seed=SEED, seed_range=3, cat_params=cat_params,
                        category_cols=None):
    print(X_tr.shape, X_te.shape)
    
    rmsle_arr = []
    best_iteration_arr = []
        
    for i, s in enumerate(range(seed, seed + seed_range)):
        seed_everything(s)
        params = cat_params.copy()
        params['random_seed'] = s
        
        regressor = CatBoostRegressor(**params)
        regressor.fit(X_tr, y_tr, eval_set=(X_te, y_te),
                cat_features=category_cols,
                use_best_model=True,
                verbose=True)

        best_iteration = regressor.best_iteration_
        best_iteration_arr.append(best_iteration)
        
        pred = regressor.predict(X_te)
        rmsle= np.sqrt(mse(y_te, pred))
        rmsle_arr.append(rmsle)
        print('seed:', s, ', rmsle:', rmsle, ', best_iteration:', best_iteration)

    rmsle_arr = np.array(rmsle_arr)
    best_iteration_arr = np.array(best_iteration_arr)
    best_iteration = int(np.mean(best_iteration_arr))
    

    print(f'avg rmsle: {np.mean(rmsle_arr):.3f}+/-{np.std(rmsle_arr):.3f}, avg best iteration: {best_iteration}')
    
    return best_iteration

best_iteration=find_Best_Iteration(X_tr, y_tr, X_te, y_te, seed=SEED, seed_range=3, cat_params=cat_params,
                        category_cols=cat_cols)

NFOLDS=5

def make_prediction(X, y, X_test, best_iteration, seed=SEED, category_cols=None):
    print('best iteration:', best_iteration)
    preds = np.zeros((X_test.shape[0], NFOLDS))
    val_preds=np.zeros(X.shape[0])

    print(X.shape, X_test.shape)
    
    kf = KFold(n_splits=NFOLDS)
    params = cat_params.copy()
    params['n_estimators'] = best_iteration
    
    for i, (trn_idx, te_idx) in enumerate(kf.split(X)):
        fold = i + 1
        print('Fold:',fold)
        
        tr_x, tr_y = X.iloc[trn_idx,:], y.iloc[trn_idx]
        te_x, te_y = X.iloc[te_idx,:], y.iloc[te_idx]
                   
        print('training set length:', len(tr_x))
        reg = CatBoostRegressor(**params)
        reg.fit(tr_x, tr_y,eval_set=(te_x,te_y),cat_features=category_cols, 
                use_best_model=False, verbose=True)
        
        val_preds[te_idx]+= reg.predict(X.iloc[te_idx])
        preds[:, i] = reg.predict(X_test)
    
    return preds, val_preds

preds,val_preds=make_prediction(X, y, X_test, best_iteration=best_iteration, seed=SEED, category_cols=cat_cols)

y_pred=np.expm1(np.mean(preds, axis=1))

y_pred.min()

np.save('pred_cat.npy', y_pred)

"""**RMSLE**"""

RMSLE(val_preds, y)

"""## **Submission**"""

submission=pd.read_csv('sample_submission.csv')

submission['visitors']=y_pred

submission.to_csv('submission_cat.csv', index=False, float_format='%.3f')

from google.colab import files

files.download('submission_cat.csv')